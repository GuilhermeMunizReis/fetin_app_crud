"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MySqlInsert = exports.MySqlInsertBuilder = void 0;
const drizzle_orm_1 = require("drizzle-orm");
const query_promise_1 = require("drizzle-orm/query-promise");
const sql_1 = require("drizzle-orm/sql");
const utils_1 = require("../utils");
class MySqlInsertBuilder {
    constructor(table, session, dialect) {
        this.table = table;
        this.session = session;
        this.dialect = dialect;
    }
    values(...values) {
        const mappedValues = values.map((entry) => {
            const result = {};
            const cols = this.table[drizzle_orm_1.Table.Symbol.Columns];
            for (const colKey of Object.keys(entry)) {
                const colValue = entry[colKey];
                if (colValue instanceof sql_1.SQL) {
                    result[colKey] = colValue;
                }
                else {
                    result[colKey] = new sql_1.Param(colValue, cols[colKey]);
                }
            }
            return result;
        });
        return new MySqlInsert(this.table, mappedValues, this.session, this.dialect);
    }
}
exports.MySqlInsertBuilder = MySqlInsertBuilder;
class MySqlInsert extends query_promise_1.QueryPromise {
    constructor(table, values, session, dialect) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.execute = (placeholderValues) => {
            return this._prepare().execute(placeholderValues);
        };
        this.config = { table, values };
    }
    // onDuplicateDoUpdate(
    // 	target:
    // 		| SQL<GetTableConfig<TTable, 'name'>>
    // 		| ((constraints: GetTableConflictConstraints<TTable>) => Check<GetTableConfig<TTable, 'name'>>),
    // 	set: MySqlUpdateSet<TTable>,
    // ): Pick<this, 'returning' | 'getQuery' | 'execute'> {
    // 	const setSql = this.dialect.buildUpdateSet<GetTableConfig<TTable, 'name'>>(this.config.table, set);
    // 	if (target instanceof SQL) {
    // 		this.config.onConflict = sql<GetTableConfig<TTable, 'name'>>`${target} do update set ${setSql}`;
    // 	} else {
    // 		const targetSql = new Name(target(this.config.table[tableConflictConstraints]).name);
    // 		this.config.onConflict = sql`on constraint ${targetSql} do update set ${setSql}`;
    // 	}
    // 	return this;
    // }
    onDuplicateKeyUpdate(config) {
        const setSql = this.dialect.buildUpdateSet(this.config.table, (0, utils_1.mapUpdateSet)(this.config.table, config.set));
        this.config.onConflict = (0, sql_1.sql) `update ${setSql}`;
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildInsertQuery(this.config);
    }
    toSQL() {
        return this.dialect.sqlToQuery(this.getSQL());
    }
    _prepare(name) {
        return this.session.prepareQuery(this.toSQL(), this.config.returning, name);
    }
    prepare(name) {
        return this._prepare(name);
    }
}
exports.MySqlInsert = MySqlInsert;
//# sourceMappingURL=insert.js.map