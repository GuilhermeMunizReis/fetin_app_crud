"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MySqlDialect = void 0;
const drizzle_orm_1 = require("drizzle-orm");
const sql_1 = require("drizzle-orm/sql");
const common_1 = require("./columns/common");
const db_1 = require("./db");
const table_1 = require("./table");
// TODO find out how to use all/values. Seems like I need those functions
// Build project
// copy runtime tests to be sure it's working
// Add mysql to drizzle-kit
// Add Planetscale Driver and create example repo
class MySqlDialect {
    migrate(migrations, session) {
        var migrations_1, migrations_1_1;
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            const migrationTableCreate = (0, sql_1.sql) `CREATE TABLE IF NOT EXISTS \`__drizzle_migrations\` (
			id SERIAL PRIMARY KEY,
			hash text NOT NULL,
			created_at bigint
		)`;
            yield session.execute(migrationTableCreate);
            const dbMigrations = yield session.all((0, sql_1.sql) `SELECT id, hash, created_at FROM \`__drizzle_migrations\` ORDER BY created_at DESC LIMIT 1`);
            const lastDbMigration = dbMigrations[0];
            yield session.execute((0, sql_1.sql) `BEGIN`);
            try {
                try {
                    for (migrations_1 = __asyncValues(migrations); migrations_1_1 = yield migrations_1.next(), !migrations_1_1.done;) {
                        const migration = migrations_1_1.value;
                        if (!lastDbMigration
                            || parseInt(lastDbMigration.created_at, 10) < migration.folderMillis) {
                            yield session.execute(sql_1.sql.raw(migration.sql));
                            yield session.execute((0, sql_1.sql) `INSERT INTO \`__drizzle_migrations\` (\`hash\`, \`created_at\`) VALUES(${migration.hash}, ${migration.folderMillis})`);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (migrations_1_1 && !migrations_1_1.done && (_a = migrations_1.return)) yield _a.call(migrations_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                yield session.execute((0, sql_1.sql) `COMMIT`);
            }
            catch (e) {
                yield session.execute((0, sql_1.sql) `ROLLBACK`);
                throw e;
            }
        });
    }
    createDB(session) {
        return new db_1.MySqlDatabase(this, session);
    }
    escapeName(name) {
        return `\`${name}\``;
    }
    escapeParam(num) {
        return `?`;
    }
    buildDeleteQuery({ table, where, returning }) {
        const returningSql = returning
            ? (0, sql_1.sql) ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const whereSql = where ? (0, sql_1.sql) ` where ${where}` : undefined;
        return (0, sql_1.sql) `delete from ${table}${whereSql}${returningSql}`;
    }
    buildUpdateSet(table, set) {
        const setEntries = Object.entries(set);
        const setSize = setEntries.length;
        return sql_1.sql.fromList(setEntries
            .map(([colName, value], i) => {
            const col = table[drizzle_orm_1.Table.Symbol.Columns][colName];
            const res = (0, sql_1.sql) `${new sql_1.Name(col.name)} = ${value}`;
            if (i < setSize - 1) {
                return [res, sql_1.sql.raw(', ')];
            }
            return [res];
        })
            .flat(1));
    }
    buildUpdateQuery({ table, set, where, returning }) {
        const setSql = this.buildUpdateSet(table, set);
        const returningSql = returning
            ? (0, sql_1.sql) ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const whereSql = where ? (0, sql_1.sql) ` where ${where}` : undefined;
        return (0, sql_1.sql) `update ${table} set ${setSql}${whereSql}${returningSql}`;
    }
    /**
     * Builds selection SQL with provided fields/expressions
     *
     * Examples:
     *
     * `select <selection> from`
     *
     * `insert ... returning <selection>`
     *
     * If `isSingleTable` is true, then columns won't be prefixed with table name
     */
    buildSelection(fields, { isSingleTable = false } = {}) {
        const columnsLen = fields.length;
        const chunks = fields
            .map(({ field }, i) => {
            const chunk = [];
            if (field instanceof sql_1.SQLResponse || field instanceof sql_1.SQL) {
                const query = field instanceof sql_1.SQLResponse ? field.sql : field;
                if (isSingleTable) {
                    chunk.push(new sql_1.SQL(query.queryChunks.map((c) => {
                        if (c instanceof common_1.MySqlColumn) {
                            return new sql_1.Name(c.name);
                        }
                        return c;
                    })));
                }
                else {
                    chunk.push(query);
                }
            }
            else if (field instanceof drizzle_orm_1.Column) {
                if (isSingleTable) {
                    chunk.push(new sql_1.Name(field.name));
                }
                else {
                    chunk.push(field);
                }
            }
            if (i < columnsLen - 1) {
                chunk.push((0, sql_1.sql) `, `);
            }
            return chunk;
        })
            .flat(1);
        return sql_1.sql.fromList(chunks);
    }
    buildSelectQuery({ fields, where, table, joins, orderBy, groupBy, limit, offset }) {
        const joinKeys = Object.keys(joins);
        const selection = this.buildSelection(fields, { isSingleTable: joinKeys.length === 0 });
        const joinsArray = [];
        joinKeys.forEach((tableAlias, index) => {
            if (index === 0) {
                joinsArray.push((0, sql_1.sql) ` `);
            }
            const joinMeta = joins[tableAlias];
            const table = joinMeta.table;
            const tableName = table[table_1.MySqlTable.Symbol.Name];
            const tableSchema = table[table_1.MySqlTable.Symbol.Schema];
            const origTableName = table[table_1.MySqlTable.Symbol.OriginalName];
            const alias = tableName === origTableName ? undefined : tableAlias;
            joinsArray.push((0, sql_1.sql) `${sql_1.sql.raw(joinMeta.joinType)} join ${tableSchema ? new sql_1.Name(tableSchema) : sql_1.sql.raw('')}${sql_1.sql.raw(tableSchema ? '.' : '')}${new sql_1.Name(origTableName)} ${alias && new sql_1.Name(alias)} on ${joinMeta.on}`);
            if (index < joinKeys.length - 1) {
                joinsArray.push((0, sql_1.sql) ` `);
            }
        });
        const joinsSql = sql_1.sql.fromList(joinsArray);
        const whereSql = where ? (0, sql_1.sql) ` where ${where}` : undefined;
        const orderByList = [];
        orderBy.forEach((orderByValue, index) => {
            orderByList.push(orderByValue);
            if (index < orderBy.length - 1) {
                orderByList.push((0, sql_1.sql) `, `);
            }
        });
        const orderBySql = orderByList.length > 0 ? (0, sql_1.sql) ` order by ${sql_1.sql.fromList(orderByList)}` : undefined;
        const groupByList = [];
        groupBy.forEach((groupByValue, index) => {
            groupByList.push(groupByValue);
            if (index < groupBy.length - 1) {
                groupByList.push((0, sql_1.sql) `, `);
            }
        });
        const groupBySql = groupByList.length > 0 ? (0, sql_1.sql) ` group by ${sql_1.sql.fromList(groupByList)}` : undefined;
        const limitSql = limit ? (0, sql_1.sql) ` limit ${limit}` : undefined;
        const offsetSql = offset ? (0, sql_1.sql) ` offset ${offset}` : undefined;
        return (0, sql_1.sql) `select ${selection} from ${table}${joinsSql}${whereSql}${groupBySql}${orderBySql}${limitSql}${offsetSql}`;
    }
    buildInsertQuery({ table, values, onConflict, returning }) {
        const isSingleValue = values.length === 1;
        const valuesSqlList = [];
        const columns = table[drizzle_orm_1.Table.Symbol.Columns];
        const colEntries = isSingleValue
            ? Object.keys(values[0]).map((fieldName) => [fieldName, columns[fieldName]])
            : Object.entries(columns);
        const insertOrder = colEntries.map(([, column]) => new sql_1.Name(column.name));
        values.forEach((value, valueIndex) => {
            const valueList = [];
            colEntries.forEach(([fieldName]) => {
                const colValue = value[fieldName];
                if (typeof colValue === 'undefined') {
                    valueList.push((0, sql_1.sql) `default`);
                }
                else {
                    valueList.push(colValue);
                }
            });
            valuesSqlList.push(valueList);
            if (valueIndex < values.length - 1) {
                valuesSqlList.push((0, sql_1.sql) `, `);
            }
        });
        const valuesSql = sql_1.sql.fromList(valuesSqlList);
        const returningSql = returning
            ? (0, sql_1.sql) ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const onConflictSql = onConflict ? (0, sql_1.sql) ` on duplicate key ${onConflict}` : undefined;
        return (0, sql_1.sql) `insert into ${table} ${insertOrder} values ${valuesSql}${onConflictSql}`;
    }
    sqlToQuery(sql) {
        return sql.toQuery({
            escapeName: this.escapeName,
            escapeParam: this.escapeParam,
        });
    }
}
exports.MySqlDialect = MySqlDialect;
//# sourceMappingURL=dialect.js.map