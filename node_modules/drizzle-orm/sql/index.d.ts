import { AnyColumn } from '../column';
import { Table } from '../table';
/**
 * This class is used to indicate a primitive param value that is used in `sql` tag.
 * It is only used on type level and is never instantiated at runtime.
 * If you see a value of this type in the code, its runtime value is actually the primitive param value.
 */
export declare class FakePrimitiveParam {
}
export declare type Chunk = string | Table | AnyColumn | Name | Param | Placeholder;
export interface BuildQueryConfig {
    escapeName(name: string): string;
    escapeParam(num: number, value: unknown): string;
}
export interface Query {
    sql: string;
    params: unknown[];
}
export interface SQLWrapper {
    getSQL(): SQL;
}
export declare function isSQLWrapper(value: unknown): value is SQLWrapper;
export declare class SQL implements SQLWrapper {
    readonly queryChunks: Chunk[];
    protected $brand: 'SQL';
    constructor(queryChunks: Chunk[]);
    toQuery({ escapeName, escapeParam }: BuildQueryConfig): Query;
    getSQL(): SQL;
    as<TDecoder extends DriverValueDecoder<any, any> | DriverValueDecoder<any, any>['mapFromDriverValue']>(decoder: TDecoder): SQLResponse<GetDecoderColumnData<TDecoder>>;
    as<TData>(): SQLResponse<TData>;
}
export declare type GetDecoderColumnData<T> = T extends DriverValueDecoder<infer TData, any> | DriverValueDecoder<infer TData, any>['mapFromDriverValue'] ? TData : never;
/**
 * Any DB name (table, column, index etc.)
 */
export declare class Name {
    readonly value: string;
    protected brand: 'Name';
    constructor(value: string);
}
/**
 * Any DB name (table, column, index etc.)
 */
export declare function name(value: string): Name;
export interface DriverValueDecoder<TData, TDriverParam> {
    mapFromDriverValue(value: TDriverParam): TData;
}
export interface DriverValueEncoder<TData, TDriverParam> {
    mapToDriverValue(value: TData): TDriverParam;
}
export declare const noopDecoder: DriverValueDecoder<any, any>;
export declare const noopEncoder: DriverValueEncoder<any, any>;
export interface DriverValueMapper<TData, TDriverParam> extends DriverValueDecoder<TData, TDriverParam>, DriverValueEncoder<TData, TDriverParam> {
}
export declare const noopMapper: DriverValueMapper<any, any>;
/** Parameter value that is optionally bound to an encoder (for example, a column). */
export declare class Param<TDataType = unknown, TDriverParamType = TDataType> {
    readonly value: TDataType;
    readonly encoder: DriverValueEncoder<TDataType, TDriverParamType>;
    protected brand: 'BoundParamValue';
    /**
     * @param value - Parameter value
     * @param encoder - Encoder to convert the value to a driver parameter
     */
    constructor(value: TDataType, encoder?: DriverValueEncoder<TDataType, TDriverParamType>);
}
export declare function param<TData, TDriver>(value: TData, encoder?: DriverValueEncoder<TData, TDriver>): Param<TData, TDriver>;
export declare type SQLSourceParam = SQLSourceParam[] | SQLWrapper | SQL | Table | AnyColumn | Param | Name | undefined | FakePrimitiveParam | Placeholder;
export declare function sql(strings: TemplateStringsArray, ...params: any[]): SQL;
export declare namespace sql {
    function empty(): SQL;
    function fromList(list: SQLSourceParam[]): SQL;
    /**
     * Convenience function to create an SQL query from a raw string.
     * @param str The raw SQL query string.
     */
    function raw(str: string): SQL;
}
export declare class SQLResponse<TValue = unknown> {
    readonly sql: SQL;
    readonly decoder: DriverValueDecoder<TValue, any>;
    protected $brand: 'SQLResponse';
    constructor(sql: SQL, decoder: DriverValueDecoder<TValue, any>);
}
export declare class Placeholder<TName extends string = string, TValue = any> {
    readonly name: TName;
    protected $brand: 'Placeholder';
    protected $type: TValue;
    constructor(name: TName);
}
export declare function placeholder<TName extends string>(name: TName): Placeholder<TName>;
export declare function fillPlaceholders(params: unknown[], values: Record<string, unknown>): unknown[];
//# sourceMappingURL=index.d.ts.map