"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fillPlaceholders = exports.placeholder = exports.Placeholder = exports.SQLResponse = exports.sql = exports.param = exports.Param = exports.noopMapper = exports.noopEncoder = exports.noopDecoder = exports.name = exports.Name = exports.SQL = exports.isSQLWrapper = exports.FakePrimitiveParam = void 0;
const column_1 = require("../column");
const table_1 = require("../table");
/**
 * This class is used to indicate a primitive param value that is used in `sql` tag.
 * It is only used on type level and is never instantiated at runtime.
 * If you see a value of this type in the code, its runtime value is actually the primitive param value.
 */
class FakePrimitiveParam {
}
exports.FakePrimitiveParam = FakePrimitiveParam;
function isSQLWrapper(value) {
    return typeof value === 'object' && value !== null && 'getSQL' in value
        && typeof value.getSQL === 'function';
}
exports.isSQLWrapper = isSQLWrapper;
class SQL {
    constructor(queryChunks) {
        this.queryChunks = queryChunks;
    }
    toQuery({ escapeName, escapeParam }) {
        const params = [];
        const chunks = this.queryChunks.map((chunk) => {
            if (typeof chunk === 'string') {
                return chunk;
            }
            else if (chunk instanceof Name) {
                return escapeName(chunk.value);
            }
            else if (chunk instanceof table_1.Table) {
                const schemaName = chunk[table_1.Table.Symbol.Schema];
                return typeof schemaName !== 'undefined'
                    ? escapeName(schemaName) + '.' + escapeName(chunk[table_1.Table.Symbol.Name])
                    : escapeName(chunk[table_1.Table.Symbol.Name]);
            }
            else if (chunk instanceof column_1.Column) {
                return escapeName(chunk.table[table_1.Table.Symbol.Name]) + '.' + escapeName(chunk.name);
            }
            else if (chunk instanceof Param) {
                params.push(chunk.encoder.mapToDriverValue(chunk.value));
                return escapeParam(params.length - 1, chunk.value);
            }
            else {
                const err = new Error('Unexpected chunk type!');
                console.error(chunk);
                throw err;
            }
        });
        const sqlString = chunks
            .join('')
            .trim();
        return { sql: sqlString, params };
    }
    getSQL() {
        return this;
    }
    as(decoder = exports.noopDecoder) {
        return new SQLResponse(this, typeof decoder === 'function' ? { mapFromDriverValue: decoder } : decoder);
    }
}
exports.SQL = SQL;
/**
 * Any DB name (table, column, index etc.)
 */
class Name {
    constructor(value) {
        this.value = value;
    }
}
exports.Name = Name;
/**
 * Any DB name (table, column, index etc.)
 */
function name(value) {
    return new Name(value);
}
exports.name = name;
exports.noopDecoder = {
    mapFromDriverValue: (value) => value,
};
exports.noopEncoder = {
    mapToDriverValue: (value) => value,
};
exports.noopMapper = Object.assign(Object.assign({}, exports.noopDecoder), exports.noopEncoder);
/** Parameter value that is optionally bound to an encoder (for example, a column). */
class Param {
    /**
     * @param value - Parameter value
     * @param encoder - Encoder to convert the value to a driver parameter
     */
    constructor(value, encoder = exports.noopEncoder) {
        this.value = value;
        this.encoder = encoder;
    }
}
exports.Param = Param;
function param(value, encoder) {
    return new Param(value, encoder);
}
exports.param = param;
function buildChunksFromParam(param) {
    if (Array.isArray(param)) {
        const result = ['('];
        param.forEach((p, i) => {
            result.push(...buildChunksFromParam(p));
            if (i < param.length - 1) {
                result.push(', ');
            }
        });
        result.push(')');
        return result;
    }
    else if (param instanceof SQL) {
        return param.queryChunks;
    }
    else if (isSQLWrapper(param)) {
        return buildChunksFromParam(param.getSQL());
    }
    else if (param instanceof table_1.Table || param instanceof column_1.Column || param instanceof Name || param instanceof Param) {
        return [param];
    }
    else if (param !== undefined) {
        return [new Param(param)];
    }
    else {
        return [];
    }
}
/*
    The type of `params` is specified as `SQLSourceParam[]`, but that's slightly incorrect -
    in runtime, users won't pass `FakePrimitiveParam` instances as `params` - they will pass primitive values
    which will be wrapped in `Param` using `buildChunksFromParam(...)`. That's why the overload
    specify `params` as `any[]` and not as `SQLSourceParam[]`. This type is used to make our lives easier and
    the type checker happy.
*/
function sql(strings, ...params) {
    const queryChunks = [];
    if (params.length > 0 || (strings.length > 0 && strings[0] !== '')) {
        queryChunks.push(strings[0]);
    }
    params.forEach((param, paramIndex) => {
        queryChunks.push(...buildChunksFromParam(param));
        queryChunks.push(strings[paramIndex + 1]);
    });
    return new SQL(queryChunks);
}
exports.sql = sql;
(function (sql) {
    function empty() {
        return new SQL([]);
    }
    sql.empty = empty;
    function fromList(list) {
        return new SQL(list.map(buildChunksFromParam).flat(1));
    }
    sql.fromList = fromList;
    /**
     * Convenience function to create an SQL query from a raw string.
     * @param str The raw SQL query string.
     */
    function raw(str) {
        return new SQL([str]);
    }
    sql.raw = raw;
})(sql = exports.sql || (exports.sql = {}));
class SQLResponse {
    constructor(sql, decoder) {
        this.sql = sql;
        this.decoder = decoder;
    }
}
exports.SQLResponse = SQLResponse;
class Placeholder {
    constructor(name) {
        this.name = name;
    }
}
exports.Placeholder = Placeholder;
function placeholder(name) {
    return new Placeholder(name);
}
exports.placeholder = placeholder;
function fillPlaceholders(params, values) {
    return params.map((p) => {
        if (p instanceof Placeholder) {
            if (!(p.name in values)) {
                throw new Error(`No value for placeholder "${p.name}" was provided`);
            }
            return values[p.name];
        }
        return p;
    });
}
exports.fillPlaceholders = fillPlaceholders;
//# sourceMappingURL=index.js.map