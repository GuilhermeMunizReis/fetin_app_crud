import { QueryPromise } from 'drizzle-orm/query-promise';
import { Param, Placeholder, Query, SQL, SQLWrapper } from 'drizzle-orm/sql';
import { PgDialect } from '../dialect';
import { IndexColumn } from '../indexes';
import { SelectFields, SelectFieldsOrdered, SelectResultFields } from '../operations';
import { PgSession, PreparedQuery, PreparedQueryConfig, QueryResultHKT, QueryResultKind } from '../session';
import { AnyPgTable, InferModel } from '../table';
import { PgUpdateSetSource } from './update';
export interface PgInsertConfig<TTable extends AnyPgTable = AnyPgTable> {
    table: TTable;
    values: Record<string, Param | SQL>[];
    onConflict?: SQL;
    returning?: SelectFieldsOrdered;
}
export declare type PgInsertValue<TTable extends AnyPgTable> = {
    [Key in keyof InferModel<TTable, 'insert'>]: InferModel<TTable, 'insert'>[Key] | SQL | Placeholder;
};
export declare class PgInsertBuilder<TTable extends AnyPgTable, TQueryResult extends QueryResultHKT> {
    private table;
    private session;
    private dialect;
    constructor(table: TTable, session: PgSession, dialect: PgDialect);
    values(...values: PgInsertValue<TTable>[]): PgInsert<TTable, TQueryResult>;
}
export interface PgInsert<TTable extends AnyPgTable, TQueryResult extends QueryResultHKT, TReturning extends Record<string, unknown> | undefined = undefined> extends QueryPromise<TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[]>, SQLWrapper {
}
export declare class PgInsert<TTable extends AnyPgTable, TQueryResult extends QueryResultHKT, TReturning extends Record<string, unknown> | undefined = undefined> extends QueryPromise<TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[]> implements SQLWrapper {
    private session;
    private dialect;
    protected $table: TTable;
    protected $return: TReturning;
    private config;
    constructor(table: TTable, values: PgInsertConfig['values'], session: PgSession, dialect: PgDialect);
    returning(): Omit<PgInsert<TTable, TQueryResult, InferModel<TTable>>, 'returning' | `onConflict${string}`>;
    returning<TSelectedFields extends SelectFields>(fields: TSelectedFields): Omit<PgInsert<TTable, TQueryResult, SelectResultFields<TSelectedFields>>, 'returning' | `onConflict${string}`>;
    onConflictDoNothing(config?: {
        target?: IndexColumn | IndexColumn[];
        where?: SQL;
    }): this;
    onConflictDoUpdate(config: {
        target: IndexColumn | IndexColumn[];
        where?: SQL;
        set: PgUpdateSetSource<TTable>;
    }): this;
    toSQL(): Query;
    private _prepare;
    prepare(name: string): PreparedQuery<PreparedQueryConfig & {
        execute: TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[];
    }>;
    execute: ReturnType<this['prepare']>['execute'];
}
//# sourceMappingURL=insert.d.ts.map